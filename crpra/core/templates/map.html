{% extends "base.html" %}
{% block title %} Mapping Los Angeles Sheriff's department shootings {% endblock %}

{% block styles %}
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
{% endblock %}
{% block scripts %}
	<script src="./static/js/leaflet.ajax.min.js"></script>
{% endblock %}

{% block content %}
	<script type="text/javascript" src="./static/js/Leaflet.heat/dist/leaflet-heat.js"></script>
	<form class="search-container" action="/search" method="GET">
	<input type="text" name="query" placeholder="Search for shooting or deputy" />
	<button type="submit">
	    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Magnifying_glass_icon.svg/512px-Magnifying_glass_icon.svg.png" alt="Search Icon">
	</button>
	</form>
	<div id="map"></div>
        <div id="databox"><h4>Listed shootings</h4> <span class="date" style="float: right;">(<a href="#cases">&darr; see legal cases below</a>)</span></div> 

	<div id="filterbox">
        <div class="form-check form-switch">
            <input class="form-check-input" onClick="toggleLayer();" type="checkbox" id="flexSwitchCheckDefault"> Show all reporting districts in county <br />
            <input id="fat" class="form-check-input" type="checkbox" id="flexSwitchCheckDefault"> Show only fatal shootings <br />
            <input id="arm" class="form-check-input" type="checkbox" id="flexSwitchCheckDefault"> Show only unarmed victims <br />
            Start year: <select id="startyear">
                    <option value='1984' selected>1984</option>
		</select>
            End year: <select id="endyear">
                    <option value='2023' selected>2023</option>
		</select>
        </div>
        </div>
        <script type="module">
	import { shootingPull } from './static/js/data.js';
        const dist_dict = {
	    "1": "MISSION",
	    "2": "DEVONSHIRE",
	    "3": "FOOTHILL",
	    "4": "TOPANGA",
	    "5": "WEST VALLEY",
	    "6": "NORTH HOLLYWOOD",
	    "7": "VAN NUYS",
	    "8": "NORTHEAST",
	    "9": "HOLLYWOOD",
	    "10": "WEST LOS ANGELES",
	    "11": "HOLLENBECK",
	    "12": "RAMPART",
	    "13": "WILSHIRE",
	    "14": "OLYMPIC",
	    "15": "SOUTHWEST",
	    "16": "NEWTON",
	    "17": "PACIFIC",
	    "18": "77TH STREET",
	    "19": "SOUTHEAST",
	    "20": "HARBOR",
	    "21": "CENTRAL"
	}

        var map = L.map('map',{
            maxZoom: 15,
            minZoom: 9,
            scrollWheelZoom: false,
            zoomControl: false}).setView([34.05, -118.51], 10);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 15,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);
        L.control.zoom({
            position: 'bottomright' // Position of the zoom control
        }).addTo(map);
	var rdStyle = {
    		fillColor: "#2c7fb8",
    		color: "#000000",
    		weight: 0.3,
    		opacity: 1,
    		fillOpacity: 0.20
	};
        var divStyle = {
                fillColor: "#b87f2c",
                color: "#000000",
                weight: 0.7,
                opacity: 1,
                fillOpacity: 0.20
        };
        var heatMap = L.heatLayer([], {radius: 9});
        heatMap.addTo(map);
	window.rayCasting = function rayCasting(point, polygon) {
	    let [lat, lng] = point;
	    let inside = false;

	    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
		const [lat1, lng1] = polygon[i];
		const [lat2, lng2] = polygon[j];

		// Check if the point is on the edge
		if ((lng1 > lng) !== (lng2 > lng) && (lat < (lat2 - lat1) * (lng - lng1) / (lng2 - lng1) + lat1)) {
		    inside = !inside;
		}
	    }

	    return inside;
	}
        window.isPointInPolygon = function isPointInPolygon(point, polygon, holes) {
	    const isInOuter = rayCasting(point, polygon);
	    const isInHole = holes.some(hole => rayCasting(point, hole));
	    return isInOuter && !isInHole;
        }

	window.loadData = async function loadData() {
          let poly = null;
          if (selected) { poly = selected.feature.geometry.coordinates; }
	  try {
            let f = document.getElementById('fat').checked;
            let a = document.getElementById('arm').checked;
    
	    let startyear = document.getElementById('startyear').value;
            let endyear = document.getElementById('endyear').value;

	    let data = await shootingPull();
            if (f) { data = data.filter(item => item.outcome === 1); }
            if (a) { data = data.filter(item => item.weapon.includes("0")); }
            data = data.filter(item => {
	        const year = new Date(item.date).getFullYear(); // Extract the year from the date
	        return year >= startyear && year <= endyear; // Check if the year is within the range
	    });
            if (poly) {
                data = data.filter(item => {
                    const itemPt = [item.lng, item.lat];
                    return isPointInPolygon(itemPt, poly[0], poly.slice(1));
                });
            }

	    let latlngs = data.filter(item => item.lat != null && item.lng != null)  // Only keep items where lat and lng are non-null
            .map(item => [item.lat, item.lng, 130])
           
            updateList(data);   
             
	    // Log the extracted lat/lng values
	    heatMap.setLatLngs(latlngs);
	    } catch (error) {
	    console.error('Error:', error);
	  }
	}

	loadData();

        var mark = null;
        window.updateList = async function updateList(data) {
            const dataBox = document.getElementById('databox');
            const shootingChildren = document.querySelectorAll('#databox .shooting');

            // Iterate over the NodeList and remove each element
            shootingChildren.forEach(child => {
                child.remove(); // Remove the child from the DOM
            });
	    // Iterate over each item in the data array
	    data.forEach(d => {
		// Create a new div element
		const childDiv = document.createElement('div');
		
                const mainContent = '<div class="shootinglabel"><a href="/shooting/' + d.victim + '">Shooting of ' + d.victim;
                const perpContent = '</a><span class="shootingperp"><a href="/deputy/' + d.officer + '">Dep. ' + d.officer + '</a></span></div>';
                const dateContent = '<div class="date">' + d.date + '</div>'
		childDiv.innerHTML = mainContent + perpContent + dateContent;
		
		// Optionally, add a class to style the child div
		childDiv.className = 'shooting';
                
                childDiv.addEventListener('click', function () {
                    // reset all bg colors, make this bg color #eeeeee
                    const shElements = document.querySelectorAll('.shooting');

		    // Loop through each element and set the background color to transparent
		    shElements.forEach(element => {
                        element.classList.remove('active');
		    });
                    childDiv.classList.toggle('active');

                    if (mark) { mark.remove(); }
                    mark = L.marker([d.lat, d.lng]).addTo(map);
                });

		// Append the new div to the parent div
		dataBox.appendChild(childDiv);
	    });
        }

        // selection logic
	var selected;
	var rdLayer = new L.GeoJSON.AJAX("./static/js/lapd_reporting_districts.geojson", { style:rdStyle, onEachFeature:districtdata });
        var divLayer = new L.GeoJSON.AJAX("/static/js/lapd_divisions.geojson", {style: divStyle, onEachFeature:districtdata });
        map.addLayer(divLayer);
	function districtdata(feature, layer){
            if (feature.id) {
	        layer.bindPopup("District: " + dist_dict[feature.id]);
            } else {
                layer.bindPopup("District: " + feature.properties.OMEGA_NAME);
            }
	    layer.on('click', function(e) {
		if (selected) {
    			// Reset selected to default style
    			divLayer.resetStyle(selected);
  		}
  		// Assign new selected
                if (selected != e.target) {
  		    selected = e.target;
		    e.target.setStyle({
		        fillOpacity: 0.55
		    });
                    const poly = feature.geometry.coordinates;
                }
                else { 
                    selected = null;
                }
                loadData();
	    });
	    layer.on('mouseover', function(e) {
		this.openPopup();
		e.target.setStyle({
		     fillOpacity: 0.55
		});
	    });
	    layer.on('mouseout', function(e) {
		this.closePopup();
		if (e.target != selected) {
		     e.target.setStyle({
		          fillOpacity: 0.20
		     });
		}
	    });
	};

	divLayer.addTo(map);
        var divVisible = true;
        window.toggleLayer = function toggleLayer() {
            if (divVisible) {
                map.removeLayer(divLayer);
                map.addLayer(rdLayer);
                map.setView([34.05, -118.51],9)
            } else {
                map.removeLayer(rdLayer);
                map.addLayer(divLayer);
                map.setView([34.05, -118.51], 10)
            }
            divVisible = !divVisible; // Update visibility status
        }
	    const startBox = document.getElementById('startyear');
	    const endBox = document.getElementById('endyear');
            const fatBox = document.getElementById('fat');
            const armBox = document.getElementById('arm');
            
            armBox.addEventListener('click', () => { loadData(); });
            fatBox.addEventListener('click', () => { loadData(); });
	    startBox.addEventListener('change', () => { loadData(); });
            endBox.addEventListener('change', () => { loadData(); });
	</script>
        <script>
	    // Get the select element
	    const startsel = document.getElementById('startyear');
	    const endsel = document.getElementById('endyear');

	    // Loop through the years from 1984 to 2023
	    for (let year = 1985; year <= 2023; year++) {
		// Create a new option element
		const option = document.createElement('option');
		option.value = year; // Set the value of the option
		option.textContent = year; // Set the displayed text of the option

		// Append the option to the select element
		startsel.appendChild(option);
	    }
	    for (let year = 2022; year >= 1984; year--) {
		// Create a new option element
		const option = document.createElement('option');
		option.value = year; // Set the value of the option
		option.textContent = year; // Set the displayed text of the option

		// Append the option to the select element
		endsel.appendChild(option);
	    }
	</script>
        <div id="container"><a name="cases"></a>
		<div class="groupboxes">
                    {% for case in cases %}
                        <div class="box"><h4>{{ case.title }}</h4>
                            <span class="date">({{ case.code }})</span> 

                            {% if case.url %}<span class="caseurl"><a href="{{ case.url }}">Knock LA article</a></span>{% endif %}
                            <div style="padding-top: 5px;" class="deplist"  id="{{ case.id }}">
                                <i>Deputies:</i>
<script>
fetch('/case-json', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ 'case': '{{ case.id }}' }),
}).then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  }).then(data => {
     const el = document.getElementById('{{ case.id }}');
     let innerH = '<i>Implicated deputies: </i>';
     let hData = data.map(d => '<a href="deputy/' + d + '">' + d + '</a>');
     el.innerHTML = innerH + hData.join(', ');
  }).catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });
</script>
                            </div>
                        </div>
                    {% endfor %}
		</div>
        </div>
{% endblock %}
